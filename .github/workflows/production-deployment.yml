name: Production Deployment

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy'
        required: true
        default: 'latest'
      environment:
        description: 'Target environment'
        required: true
        default: 'production'
        type: choice
        options:
        - staging
        - production
      validation_only:
        description: 'Run validation only (no deployment)'
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  validate:
    name: Pre-Deployment Validation
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    outputs:
      validation_passed: ${{ steps.validation.outputs.passed }}
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pyyaml requests

    - name: Validate Kubernetes Manifests
      run: |
        echo "üîç Validating Kubernetes manifests..."
        for file in k8s/*.yaml; do
          echo "Checking $file..."
          if ! kubectl --dry-run=client apply -f "$file" --namespace repo-scanner >/dev/null 2>&1; then
            echo "‚ùå Invalid manifest: $file"
            exit 1
          fi
        done
        echo "‚úÖ All Kubernetes manifests are valid"

    - name: Validate Helm Chart
      run: |
        echo "üîç Validating Helm chart..."
        if ! helm template repo-scanner ./helm/repo-scanner --dry-run >/dev/null 2>&1; then
          echo "‚ùå Helm template failed"
          exit 1
        fi
        if ! helm lint ./helm/repo-scanner >/dev/null 2>&1; then
          echo "‚ùå Helm lint failed"
          exit 1
        fi
        echo "‚úÖ Helm chart is valid"

    - name: Run Comprehensive Validation
      id: validation
      run: |
        echo "üîç Running comprehensive deployment validation..."
        if python scripts/validate_deployment_comprehensive.py \
             --namespace repo-scanner \
             --output validation_results.json; then
          echo "‚úÖ Validation completed successfully"
          echo "passed=true" >> $GITHUB_OUTPUT
        else
          echo "‚ùå Validation failed"
          echo "passed=false" >> $GITHUB_OUTPUT
          exit 1
        fi

    - name: Upload Validation Results
      uses: actions/upload-artifact@v4
      with:
        name: validation-results-${{ github.run_id }}
        path: validation_results.json

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: validate
    environment: staging
    if: github.event.inputs.environment == 'staging' && !github.event.inputs.validation_only
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config

    - name: Deploy to Staging
      run: |
        echo "üöÄ Deploying to staging environment..."

        # Create namespace if it doesn't exist
        kubectl create namespace repo-scanner --dry-run=client -o yaml | kubectl apply -f -

        # Deploy using Helm
        helm upgrade --install repo-scanner ./helm/repo-scanner \
          --namespace repo-scanner \
          --set image.tag=${{ github.event.inputs.version }} \
          --set ingress.enabled=true \
          --set ingress.hosts[0].host=staging-scanner.yourcompany.com \
          --wait \
          --timeout=10m

        echo "‚úÖ Staging deployment completed"

    - name: Validate Staging Deployment
      run: |
        echo "üîç Validating staging deployment..."

        # Wait for deployment to be ready
        kubectl wait --for=condition=available --timeout=300s deployment/repo-scanner -n repo-scanner

        # Run health checks
        kubectl run test-pod --image=curlimages/curl --rm -i --restart=Never -- \
          curl -f http://repo-scanner.repo-scanner.svc.cluster.local/health

        echo "‚úÖ Staging validation completed"

    - name: Run Staging Tests
      run: |
        echo "üß™ Running staging tests..."

        # Run basic API tests
        python scripts/load_test.py \
          --url http://repo-scanner.repo-scanner.svc.cluster.local/health \
          --threads 10 \
          --duration 30 \
          --json > staging_performance.json

        echo "‚úÖ Staging tests completed"

    - name: Upload Staging Results
      uses: actions/upload-artifact@v4
      with:
        name: staging-results-${{ github.run_id }}
        path: staging_performance.json

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [validate, deploy-staging]
    environment: production
    if: github.event.inputs.environment == 'production' && !github.event.inputs.validation_only && needs.validate.outputs.validation_passed == 'true'
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Require Manual Approval
      run: |
        echo "‚è≥ Waiting for manual approval for production deployment..."
        # This would typically require manual approval in GitHub

    - name: Configure kubectl for Production
      run: |
        echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config

    - name: Backup Current Production State
      run: |
        echo "üíæ Creating production backup..."

        # Backup Helm release values
        helm get values repo-scanner -n repo-scanner > production_backup_values.yaml

        # Create snapshot (if using Velero or similar)
        # velero backup create pre-deploy-backup-$(date +%Y%m%d-%H%M%S) \
        #   --include-namespaces repo-scanner

        echo "‚úÖ Production backup completed"

    - name: Deploy to Production
      run: |
        echo "üöÄ Deploying to production environment..."

        # Deploy using Helm with production values
        helm upgrade --install repo-scanner ./helm/repo-scanner \
          --namespace repo-scanner \
          --set image.tag=${{ github.event.inputs.version }} \
          --set api.replicas=3 \
          --set ingress.enabled=true \
          --set ingress.hosts[0].host=scanner.yourcompany.com \
          --set monitoring.enabled=true \
          --set autoscaling.enabled=true \
          --set networkPolicy.enabled=true \
          --wait \
          --timeout=15m

        echo "‚úÖ Production deployment completed"

    - name: Validate Production Deployment
      run: |
        echo "üîç Validating production deployment..."

        # Wait for deployment to be ready
        kubectl wait --for=condition=available --timeout=600s deployment/repo-scanner -n repo-scanner

        # Check all components
        kubectl get pods -n repo-scanner
        kubectl get services -n repo-scanner
        kubectl get ingress -n repo-scanner

        # Test health endpoint
        kubectl run test-pod --image=curlimages/curl --rm -i --restart=Never -- \
          curl -f https://scanner.yourcompany.com/health

        echo "‚úÖ Production validation completed"

    - name: Run Production Smoke Tests
      run: |
        echo "üß™ Running production smoke tests..."

        # Run comprehensive API tests
        python scripts/performance_benchmark.py \
          --url https://scanner.yourcompany.com \
          --test-type health \
          --output production_smoke_test.json

        echo "‚úÖ Production smoke tests completed"

    - name: Update Production Status
      run: |
        echo "üìä Updating production status..."

        # Update monitoring dashboards
        # Send notifications to stakeholders
        # Update documentation with new version

        echo "‚úÖ Production deployment successful"
        echo "üéâ Repository Intelligence Scanner v${{ github.event.inputs.version }} is now live in production!"

    - name: Upload Production Results
      uses: actions/upload-artifact@v4
      with:
        name: production-results-${{ github.run_id }}
        path: |
          production_backup_values.yaml
          production_smoke_test.json

  rollback:
    name: Rollback Production
    runs-on: ubuntu-latest
    needs: deploy-production
    if: failure() && github.event.inputs.environment == 'production'
    environment: production
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Configure kubectl for Production
      run: |
        echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config

    - name: Rollback Deployment
      run: |
        echo "üîÑ Rolling back production deployment..."

        # Rollback Helm release
        helm rollback repo-scanner 1 -n repo-scanner

        # Wait for rollback to complete
        kubectl wait --for=condition=available --timeout=300s deployment/repo-scanner -n repo-scanner

        echo "‚úÖ Rollback completed"

    - name: Notify Rollback
      run: |
        echo "‚ö†Ô∏è Production deployment failed and was rolled back"
        # Send notifications about rollback

  notify:
    name: Notify Stakeholders
    runs-on: ubuntu-latest
    needs: [validate, deploy-staging, deploy-production, rollback]
    if: always()
    steps:
    - name: Send Notification
      run: |
        if [ "${{ needs.deploy-production.result }}" == "success" ]; then
          echo "üéâ Production deployment successful!"
        elif [ "${{ needs.rollback.result }}" == "success" ]; then
          echo "‚ö†Ô∏è Production deployment failed and was rolled back"
        else
          echo "‚ùå Deployment process encountered issues"
        fi

        # Here you would integrate with your notification system
        # (Slack, email, PagerDuty, etc.)